<html>
 <head>
  <link href="../docs.css" rel="stylesheet" type="text/css" />
 </head>
 <body>
  <h1>Design overview</h1>
  <p class="intro">This document explains the overall architecture and
  design choices of Webwidgets. It answers both the how:s and the
  why:s.</p>

  <h2>User interfaces as widget trees</h2>
  <p>In Webwidgets, everything you see is a widget. Even an
  application is a widget. Each such widget in turn might consist of
  several other widgets, either by incorporationg them as child
  widgets or by subclassing them.<p>

  <p class="rationale">The aim of this is to encourage and ease code
  re-use - user interface functionality can easily be packaged and
  reused throughout a set of applications.</p>


  <h2>Statefull widgets</h2>
  <p>Each widget is implemented as a Python class. A web user session
  then consists of one or more instance of such classes.</p>

  <p>As these instances are part of the session, they survive between
  page-loads, and member variables of the widget, such as the one
  holding the value for a string input box or the label string for a
  button, stay the same until actively changed by the user (for input
  widgets) or by the application code.</p>

  <p class="rationale">This removes the burden of re-creating the user
  interface at each page-load, re-reading values from the database at
  each page-load, and manually managing session content.</p>


  <h2>Notifications</h2>
  <p>As soon as an attribute of a widget is changed, either by user
  input or by some code, a notification is sent to the widget. This
  notification is named as the attribute, with <tt>Changed</tt>
  appended, e.g. <tt>valueChanged</tt> for the <tt>value</tt>
  attribute, and raised with the new value as sole parameter.</p>

  <p>A notification is implemented as a call to a method on the widget
  with a special first parameter <tt>path</tt> that holds the path to
  the widget. Unless that method breaks out by raising a
  <tt>StopIteration</tt> exception, the notification is propagated to
  the parent widget up to the top-level <tt>Window</tt>. All the way
  through this propagation, the <tt>path</tt> parameter stays the
  same, pointing to the originally notified widget.</p>

  <p class="rationale">The propagation makes it possible to implement
  a complicated widget with many field, with a single funtion to
  handle all state changes and calculate a compound value of some sort
  for the widget.</p>


  <h2>Input handling</h2>
  <p>Input handling is done using two special method,
  <tt>fieldInput</tt> and <tt>fieldOutput</tt>. The former method is
  called with a list of field values, and can update any attributes on
  the widget as it sees fit. This in turn raises notifications as
  usual. The latter method is used to query the widget for its current
  state, and should return a list of the same format. This is used to
  inhibit calls to fieldInput when the user hasn't actually changed
  anything.</p>


  <h2>URL argument handling</h2>
  <p>URL arguments (<tt>GET</tt> parameters) are grafted onto the
  Webwidgets framework, wich is based on a global HTML form and
  <tt>POST</tt>. Their main purpose is to allow the user to bookmark a
  page, and as an alternative way of user input and output.</p>

  <p>URL arguments allways corresponds to widget attribute values. If
  not, the widget attributes are updated (and notifications sent as
  usual).</p>

  <p>However, all widget attributes need not be present in the URL,
  and specifically, attributes of hidden widgets are never present in
  the URL. If a previously hidden widget is made visible, and it has
  attributes that are supposed to be in the URL, the browser is sent a
  HTTP redirect to an new URL containing those new values.</p>

  <p class="rationale">This provides the functionality the user
  expects, while requiring the least amount of effort from the
  application programmer.</p>


  <h2>Instantiation and initialization</h2>
  <p>When a session is created, a <tt>Window</tt> widget is
  instantiated, and with it any number of child widgets. This child
  widget instantiation can be done either automatically or manually
  from the initialization method of the parent widget.</p>

  <p>If the child widget does not need any special parameters for its
  initialization method, it can be instantiated automatically, and no
  special code is required except the child widget class being a class
  member of the parent widget class.</p>

  <p>If the child widget class is to be a class member of the parent
  widget class and still not be instantiated automatically, it has to
  set a special class member variable. Regardless, child widgets that
  are to be instantiated manually shoudl be done so with in the
  initialization function of the parent widget, which should give
  those children as parameters to its superclass initialization
  function.</p>

  <p class="rationale">It is practical to encapsulate child widget
  classes within the parent widget class, as this makes the widget
  more portable and parts of it more overridable. The automatic
  instantiation solves the problem nine times out of ten in
  practice.</p>


  <h2>Windows</h2>
  <p>A webwidget application can provide the user with several
  separate pages, or windows, each with its own widget tree and its
  own URL. These windows are created by the application after the user
  having navigated to the corresponding URL, and must be destroyed by
  the application code manually (ultimately, they are destroyed as the
  session is destroyed when it times out).</p>

  <p class="rationale">It is sometimes desirable to have separate
  pop-up-windows or frames with their own state. This functionality
  provides that.</p>


  <h2>Raw data output</h2>
  <p>Raw data, e.g. an image stored in a widget or a widget class,
  that is to be included by the widget, can be output using a special
  method on the widget instance or class which is called by accesssing
  a specially crafted URL.</p>

 </body>
</html>
